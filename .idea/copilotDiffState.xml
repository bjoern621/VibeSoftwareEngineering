<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/application/service/ArchivingService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/application/service/ArchivingService.java" />
              <option name="updatedContent" value="package com.travelreimburse.application.service;&#10;&#10;import com.travelreimburse.domain.exception.CannotArchiveTravelRequestException;&#10;import com.travelreimburse.domain.model.TravelRequest;&#10;import com.travelreimburse.domain.repository.TravelRequestRepository;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;&#10;/**&#10; * Application Service für Archivierung.&#10; * Orchestriert Use Cases - KEINE Business-Logik!&#10; */&#10;@Service&#10;@Transactional(readOnly = true)&#10;public class ArchivingService {&#10;    &#10;    private final TravelRequestRepository repository;&#10;    &#10;    public ArchivingService(TravelRequestRepository repository) {&#10;        this.repository = repository;&#10;    }&#10;    &#10;    /**&#10;     * Use Case: Einzelne Reise archivieren&#10;     */&#10;    @Transactional&#10;    public TravelRequest archiveTravelRequest(Long requestId) {&#10;        TravelRequest request = repository.findById(requestId)&#10;            .orElseThrow(() -&gt; new TravelRequestNotFoundException(requestId));&#10;        &#10;        // Business-Logik in Entity!&#10;        request.archive();&#10;        &#10;        return repository.save(request);&#10;    }&#10;    &#10;    /**&#10;     * Use Case: Reise mit benutzerdefinierter Frist archivieren&#10;     */&#10;    @Transactional&#10;    public TravelRequest archiveWithCustomRetention(Long requestId, int retentionYears) {&#10;        TravelRequest request = repository.findById(requestId)&#10;            .orElseThrow(() -&gt; new TravelRequestNotFoundException(requestId));&#10;        &#10;        request.archiveWithCustomRetention(retentionYears);&#10;        &#10;        return repository.save(request);&#10;    }&#10;    &#10;    /**&#10;     * Use Case: Alle bereiten Reisen automatisch archivieren (Batch)&#10;     */&#10;    @Transactional&#10;    public int archiveAllReadyRequests() {&#10;        List&lt;TravelRequest&gt; readyForArchiving = repository.findAllReadyForArchiving();&#10;        &#10;        int archivedCount = 0;&#10;        for (TravelRequest request : readyForArchiving) {&#10;            try {&#10;                request.archive();&#10;                repository.save(request);&#10;                archivedCount++;&#10;            } catch (CannotArchiveTravelRequestException e) {&#10;                // Log und weiter (skip)&#10;            }&#10;        }&#10;        &#10;        return archivedCount;&#10;    }&#10;    &#10;    /**&#10;     * Query: Finde Reisen mit abgelaufener Frist&#10;     */&#10;    public List&lt;TravelRequest&gt; findExpiredRetentionRequests() {&#10;        return repository.findAllWithExpiredRetention();&#10;    }&#10;    &#10;    /**&#10;     * Query: Archivierte Reisen in Zeitraum&#10;     */&#10;    public List&lt;TravelRequest&gt; findArchivedInPeriod(LocalDate start, LocalDate end) {&#10;        return repository.findArchivedBetween(start, end);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/domain/model/TravelRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/domain/model/TravelRequest.java" />
              <option name="originalContent" value="package com.travelreimburse.domain.model;&#10;&#10;import com.travelreimburse.domain.event.travelrequest.TravelRequestStatusChangedEvent;&#10;import com.travelreimburse.domain.exception.InvalidStatusTransitionException;&#10;import jakarta.persistence.*;&#10;import org.springframework.data.domain.AbstractAggregateRoot;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Aggregate Root für Reiseanträge&#10; * Verwaltet alle Informationen zu einer beantragten Dienstreise inklusive Reiserouten&#10; */&#10;@Entity&#10;@Table(name = &quot;travel_requests&quot;)&#10;public class TravelRequest extends AbstractAggregateRoot&lt;TravelRequest&gt; {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false)&#10;    private Long employeeId;&#10;    &#10;    @Column(nullable = false, length = 500)&#10;    private String destination;&#10;    &#10;    @Column(nullable = false, length = 1000)&#10;    private String purpose;&#10;    &#10;    @Embedded&#10;    private DateRange travelPeriod;&#10;    &#10;    @Embedded&#10;    @AttributeOverrides({&#10;        @AttributeOverride(name = &quot;amount&quot;, column = @Column(name = &quot;estimated_amount&quot;)),&#10;        @AttributeOverride(name = &quot;currency&quot;, column = @Column(name = &quot;estimated_currency&quot;))&#10;    })&#10;    private Money estimatedCost;&#10;    &#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private TravelRequestStatus status;&#10;    &#10;    @Column(nullable = false)&#10;    private LocalDateTime createdAt;&#10;    &#10;    @Column&#10;    private LocalDateTime submittedAt;&#10;    &#10;    @Column&#10;    private Long approverId;&#10;&#10;    @Column&#10;    private LocalDateTime approvedAt;&#10;&#10;    @Column&#10;    private LocalDateTime rejectedAt;&#10;&#10;    @Column(length = 1000)&#10;    private String rejectionReason;&#10;    &#10;    @OneToMany(mappedBy = &quot;travelRequest&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private List&lt;TravelLeg&gt; travelLegs = new ArrayList&lt;&gt;();&#10;&#10;    // JPA benötigt Default-Konstruktor&#10;    protected TravelRequest() {&#10;    }&#10;    &#10;    /**&#10;     * Erstellt einen neuen Reiseantrag im Status DRAFT&#10;     */&#10;    public TravelRequest(Long employeeId, String destination, String purpose, &#10;                         DateRange travelPeriod, Money estimatedCost) {&#10;        if (employeeId == null) {&#10;            throw new IllegalArgumentException(&quot;EmployeeId darf nicht null sein&quot;);&#10;        }&#10;        if (destination == null || destination.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reiseziel darf nicht leer sein&quot;);&#10;        }&#10;        if (purpose == null || purpose.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reisezweck darf nicht leer sein&quot;);&#10;        }&#10;        if (travelPeriod == null) {&#10;            throw new IllegalArgumentException(&quot;Reisezeitraum darf nicht null sein&quot;);&#10;        }&#10;        if (estimatedCost == null) {&#10;            throw new IllegalArgumentException(&quot;Geschätzte Kosten dürfen nicht null sein&quot;);&#10;        }&#10;        &#10;        this.employeeId = employeeId;&#10;        this.destination = destination;&#10;        this.purpose = purpose;&#10;        this.travelPeriod = travelPeriod;&#10;        this.estimatedCost = estimatedCost;&#10;        this.status = TravelRequestStatus.DRAFT;&#10;        this.createdAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag einreichen&#10;     * Zustandsübergang: DRAFT -&gt; SUBMITTED&#10;     */&#10;    public void submit() {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur Entwürfe können eingereicht werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.SUBMITTED;&#10;        this.submittedAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag genehmigen&#10;     * Zustandsübergang: SUBMITTED -&gt; APPROVED&#10;     *&#10;     * @param approverId ID der genehmigenden Führungskraft&#10;     */&#10;    public void approve(Long approverId) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können genehmigt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.APPROVED;&#10;        this.approverId = approverId;&#10;        this.approvedAt = LocalDateTime.now();&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Reiseantrag ablehnen&#10;     * Zustandsübergang: SUBMITTED -&gt; REJECTED&#10;     *&#10;     * @param approverId ID der ablehnenden Führungskraft&#10;     * @param reason Grund für die Ablehnung&#10;     */&#10;    public void reject(Long approverId, String reason) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (reason == null || reason.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Ablehnungsgrund darf nicht leer sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können abgelehnt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.REJECTED;&#10;        this.approverId = approverId;&#10;        this.rejectedAt = LocalDateTime.now();&#10;        this.rejectionReason = reason;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt hinzufügen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public TravelLeg addTravelLeg(String departureLocation, String arrivalLocation, &#10;                                  TransportationType transportationType, Money cost) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus hinzugefügt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg travelLeg = new TravelLeg(this, departureLocation, arrivalLocation, &#10;                                            transportationType, cost);&#10;        this.travelLegs.add(travelLeg);&#10;        return travelLeg;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLeg(TravelLeg travelLeg) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        if (travelLeg == null) {&#10;            throw new IllegalArgumentException(&quot;TravelLeg darf nicht null sein&quot;);&#10;        }&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        travelLeg.setTravelRequest(null);&#10;        this.travelLegs.remove(travelLeg);&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt anhand der ID entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLegById(Long legId) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg legToRemove = this.travelLegs.stream()&#10;            .filter(leg -&gt; leg.getId() != null &amp;&amp; leg.getId().equals(legId))&#10;            .findFirst()&#10;            .orElseThrow(() -&gt; new IllegalArgumentException(&quot;TravelLeg mit ID &quot; + legId + &quot; nicht gefunden&quot;));&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        legToRemove.setTravelRequest(null);&#10;        this.travelLegs.remove(legToRemove);&#10;    }&#10;    &#10;    /**&#10;     * Gibt eine unveränderliche Liste aller Reiseabschnitte zurück&#10;     */&#10;    public List&lt;TravelLeg&gt; getTravelLegs() {&#10;        return Collections.unmodifiableList(travelLegs);&#10;    }&#10;    &#10;    /**&#10;     * Berechnet die Gesamtkosten aller Reiseabschnitte&#10;     * Alle Währungen müssen identisch sein&#10;     */&#10;    public Money calculateTotalLegCost() {&#10;        if (travelLegs.isEmpty()) {&#10;            return estimatedCost;&#10;        }&#10;        &#10;        Currency baseCurrency = travelLegs.get(0).getCost().getCurrency();&#10;        Money total = new Money(java.math.BigDecimal.ZERO, baseCurrency);&#10;        &#10;        for (TravelLeg leg : travelLegs) {&#10;            if (!leg.getCost().getCurrency().equals(baseCurrency)) {&#10;                throw new IllegalStateException(&#10;                    &quot;Alle Reiseabschnitte müssen die gleiche Währung haben&quot;&#10;                );&#10;            }&#10;            total = new Money(&#10;                total.getAmount().add(leg.getCost().getAmount()), &#10;                baseCurrency&#10;            );&#10;        }&#10;        &#10;        return total;&#10;    }&#10;&#10;    // Getters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;    &#10;    public Long getEmployeeId() {&#10;        return employeeId;&#10;    }&#10;    &#10;    public String getDestination() {&#10;        return destination;&#10;    }&#10;    &#10;    public String getPurpose() {&#10;        return purpose;&#10;    }&#10;    &#10;    public DateRange getTravelPeriod() {&#10;        return travelPeriod;&#10;    }&#10;    &#10;    public Money getEstimatedCost() {&#10;        return estimatedCost;&#10;    }&#10;    &#10;    public TravelRequestStatus getStatus() {&#10;        return status;&#10;    }&#10;    &#10;    public LocalDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;    &#10;    public LocalDateTime getSubmittedAt() {&#10;        return submittedAt;&#10;    }&#10;&#10;    public Long getApproverId() {&#10;        return approverId;&#10;    }&#10;&#10;    public LocalDateTime getApprovedAt() {&#10;        return approvedAt;&#10;    }&#10;&#10;    public LocalDateTime getRejectedAt() {&#10;        return rejectedAt;&#10;    }&#10;&#10;    public String getRejectionReason() {&#10;        return rejectionReason;&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Status ändern mit Validierung und Event Publishing&#10;     * DDD: Rich Domain Model - Business logic belongs in the entity&#10;     */&#10;    public void updateStatus(TravelRequestStatus newStatus) {&#10;        if (newStatus == null) {&#10;            throw new IllegalArgumentException(&quot;Status cannot be null&quot;);&#10;        }&#10;        if (!canTransitionTo(newStatus)) {&#10;            throw new InvalidStatusTransitionException(&#10;                String.format(&quot;Cannot transition from %s to %s for TravelRequest %d&quot;,&#10;                    this.status, newStatus, this.id)&#10;            );&#10;        }&#10;&#10;        TravelRequestStatus oldStatus = this.status;&#10;        this.status = newStatus;&#10;&#10;        // Register domain event (will be published on save)&#10;        registerEvent(new TravelRequestStatusChangedEvent(&#10;            this.id,&#10;            oldStatus,&#10;            newStatus&#10;        ));&#10;    }&#10;&#10;    /**&#10;     * Business logic for valid status transitions.&#10;     * State machine implementation.&#10;     */&#10;    private boolean canTransitionTo(TravelRequestStatus targetStatus) {&#10;        if (this.status == targetStatus) {&#10;            return false;&#10;        }&#10;&#10;        return switch (this.status) {&#10;            case DRAFT -&gt; targetStatus == TravelRequestStatus.SUBMITTED;&#10;            case SUBMITTED -&gt; targetStatus == TravelRequestStatus.APPROVED ||&#10;                             targetStatus == TravelRequestStatus.REJECTED;&#10;            case APPROVED -&gt; targetStatus == TravelRequestStatus.COMPLETED ||&#10;                            targetStatus == TravelRequestStatus.CANCELLED;&#10;            case REJECTED, CANCELLED, COMPLETED -&gt; false;&#10;        };&#10;    }&#10;&#10;    /**&#10;     * @deprecated Use updateStatus() instead for business logic and event publishing&#10;     */&#10;    @Deprecated(forRemoval = true)&#10;    public void setStatus(TravelRequestStatus status) {&#10;        this.status = status;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.travelreimburse.domain.model;&#10;&#10;import com.travelreimburse.domain.event.travelrequest.TravelRequestStatusChangedEvent;&#10;import com.travelreimburse.domain.exception.CannotArchiveTravelRequestException;&#10;import com.travelreimburse.domain.exception.InvalidStatusTransitionException;&#10;import jakarta.persistence.*;&#10;import org.springframework.data.domain.AbstractAggregateRoot;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Aggregate Root für Reiseanträge&#10; * Verwaltet alle Informationen zu einer beantragten Dienstreise inklusive Reiserouten&#10; */&#10;@Entity&#10;@Table(name = &quot;travel_requests&quot;)&#10;public class TravelRequest extends AbstractAggregateRoot&lt;TravelRequest&gt; {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false)&#10;    private Long employeeId;&#10;    &#10;    @Column(nullable = false, length = 500)&#10;    private String destination;&#10;    &#10;    @Column(nullable = false, length = 1000)&#10;    private String purpose;&#10;    &#10;    @Embedded&#10;    private DateRange travelPeriod;&#10;    &#10;    @Embedded&#10;    @AttributeOverrides({&#10;        @AttributeOverride(name = &quot;amount&quot;, column = @Column(name = &quot;estimated_amount&quot;)),&#10;        @AttributeOverride(name = &quot;currency&quot;, column = @Column(name = &quot;estimated_currency&quot;))&#10;    })&#10;    private Money estimatedCost;&#10;    &#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private TravelRequestStatus status;&#10;    &#10;    @Column(nullable = false)&#10;    private LocalDateTime createdAt;&#10;    &#10;    @Column&#10;    private LocalDateTime submittedAt;&#10;    &#10;    @Column&#10;    private Long approverId;&#10;&#10;    @Column&#10;    private LocalDateTime approvedAt;&#10;&#10;    @Column&#10;    private LocalDateTime rejectedAt;&#10;&#10;    @Column(length = 1000)&#10;    private String rejectionReason;&#10;    &#10;    @Embedded&#10;    private RetentionPeriod retentionPeriod;&#10;&#10;    @OneToMany(mappedBy = &quot;travelRequest&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private List&lt;TravelLeg&gt; travelLegs = new ArrayList&lt;&gt;();&#10;&#10;    // JPA benötigt Default-Konstruktor&#10;    protected TravelRequest() {&#10;    }&#10;    &#10;    /**&#10;     * Erstellt einen neuen Reiseantrag im Status DRAFT&#10;     */&#10;    public TravelRequest(Long employeeId, String destination, String purpose, &#10;                         DateRange travelPeriod, Money estimatedCost) {&#10;        if (employeeId == null) {&#10;            throw new IllegalArgumentException(&quot;EmployeeId darf nicht null sein&quot;);&#10;        }&#10;        if (destination == null || destination.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reiseziel darf nicht leer sein&quot;);&#10;        }&#10;        if (purpose == null || purpose.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reisezweck darf nicht leer sein&quot;);&#10;        }&#10;        if (travelPeriod == null) {&#10;            throw new IllegalArgumentException(&quot;Reisezeitraum darf nicht null sein&quot;);&#10;        }&#10;        if (estimatedCost == null) {&#10;            throw new IllegalArgumentException(&quot;Geschätzte Kosten dürfen nicht null sein&quot;);&#10;        }&#10;        &#10;        this.employeeId = employeeId;&#10;        this.destination = destination;&#10;        this.purpose = purpose;&#10;        this.travelPeriod = travelPeriod;&#10;        this.estimatedCost = estimatedCost;&#10;        this.status = TravelRequestStatus.DRAFT;&#10;        this.createdAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag einreichen&#10;     * Zustandsübergang: DRAFT -&gt; SUBMITTED&#10;     */&#10;    public void submit() {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur Entwürfe können eingereicht werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.SUBMITTED;&#10;        this.submittedAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag genehmigen&#10;     * Zustandsübergang: SUBMITTED -&gt; APPROVED&#10;     *&#10;     * @param approverId ID der genehmigenden Führungskraft&#10;     */&#10;    public void approve(Long approverId) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können genehmigt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.APPROVED;&#10;        this.approverId = approverId;&#10;        this.approvedAt = LocalDateTime.now();&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Reiseantrag ablehnen&#10;     * Zustandsübergang: SUBMITTED -&gt; REJECTED&#10;     *&#10;     * @param approverId ID der ablehnenden Führungskraft&#10;     * @param reason Grund für die Ablehnung&#10;     */&#10;    public void reject(Long approverId, String reason) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (reason == null || reason.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Ablehnungsgrund darf nicht leer sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können abgelehnt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.REJECTED;&#10;        this.approverId = approverId;&#10;        this.rejectedAt = LocalDateTime.now();&#10;        this.rejectionReason = reason;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt hinzufügen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public TravelLeg addTravelLeg(String departureLocation, String arrivalLocation, &#10;                                  TransportationType transportationType, Money cost) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus hinzugefügt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg travelLeg = new TravelLeg(this, departureLocation, arrivalLocation, &#10;                                            transportationType, cost);&#10;        this.travelLegs.add(travelLeg);&#10;        return travelLeg;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLeg(TravelLeg travelLeg) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        if (travelLeg == null) {&#10;            throw new IllegalArgumentException(&quot;TravelLeg darf nicht null sein&quot;);&#10;        }&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        travelLeg.setTravelRequest(null);&#10;        this.travelLegs.remove(travelLeg);&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt anhand der ID entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLegById(Long legId) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg legToRemove = this.travelLegs.stream()&#10;            .filter(leg -&gt; leg.getId() != null &amp;&amp; leg.getId().equals(legId))&#10;            .findFirst()&#10;            .orElseThrow(() -&gt; new IllegalArgumentException(&quot;TravelLeg mit ID &quot; + legId + &quot; nicht gefunden&quot;));&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        legToRemove.setTravelRequest(null);&#10;        this.travelLegs.remove(legToRemove);&#10;    }&#10;    &#10;    /**&#10;     * Gibt eine unveränderliche Liste aller Reiseabschnitte zurück&#10;     */&#10;    public List&lt;TravelLeg&gt; getTravelLegs() {&#10;        return Collections.unmodifiableList(travelLegs);&#10;    }&#10;    &#10;    /**&#10;     * Berechnet die Gesamtkosten aller Reiseabschnitte&#10;     * Alle Währungen müssen identisch sein&#10;     */&#10;    public Money calculateTotalLegCost() {&#10;        if (travelLegs.isEmpty()) {&#10;            return estimatedCost;&#10;        }&#10;        &#10;        Currency baseCurrency = travelLegs.get(0).getCost().getCurrency();&#10;        Money total = new Money(java.math.BigDecimal.ZERO, baseCurrency);&#10;        &#10;        for (TravelLeg leg : travelLegs) {&#10;            if (!leg.getCost().getCurrency().equals(baseCurrency)) {&#10;                throw new IllegalStateException(&#10;                    &quot;Alle Reiseabschnitte müssen die gleiche Währung haben&quot;&#10;                );&#10;            }&#10;            total = new Money(&#10;                total.getAmount().add(leg.getCost().getAmount()), &#10;                baseCurrency&#10;            );&#10;        }&#10;        &#10;        return total;&#10;    }&#10;&#10;    // Getters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;    &#10;    public Long getEmployeeId() {&#10;        return employeeId;&#10;    }&#10;    &#10;    public String getDestination() {&#10;        return destination;&#10;    }&#10;    &#10;    public String getPurpose() {&#10;        return purpose;&#10;    }&#10;    &#10;    public DateRange getTravelPeriod() {&#10;        return travelPeriod;&#10;    }&#10;    &#10;    public Money getEstimatedCost() {&#10;        return estimatedCost;&#10;    }&#10;    &#10;    public TravelRequestStatus getStatus() {&#10;        return status;&#10;    }&#10;    &#10;    public LocalDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;    &#10;    public LocalDateTime getSubmittedAt() {&#10;        return submittedAt;&#10;    }&#10;&#10;    public Long getApproverId() {&#10;        return approverId;&#10;    }&#10;&#10;    public LocalDateTime getApprovedAt() {&#10;        return approvedAt;&#10;    }&#10;&#10;    public LocalDateTime getRejectedAt() {&#10;        return rejectedAt;&#10;    }&#10;&#10;    public String getRejectionReason() {&#10;        return rejectionReason;&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Status ändern mit Validierung und Event Publishing&#10;     * DDD: Rich Domain Model - Business logic belongs in the entity&#10;     */&#10;    public void updateStatus(TravelRequestStatus newStatus) {&#10;        if (newStatus == null) {&#10;            throw new IllegalArgumentException(&quot;Status cannot be null&quot;);&#10;        }&#10;        if (!canTransitionTo(newStatus)) {&#10;            throw new InvalidStatusTransitionException(&#10;                String.format(&quot;Cannot transition from %s to %s for TravelRequest %d&quot;,&#10;                    this.status, newStatus, this.id)&#10;            );&#10;        }&#10;&#10;        TravelRequestStatus oldStatus = this.status;&#10;        this.status = newStatus;&#10;&#10;        // Register domain event (will be published on save)&#10;        registerEvent(new TravelRequestStatusChangedEvent(&#10;            this.id,&#10;            oldStatus,&#10;            newStatus&#10;        ));&#10;    }&#10;&#10;    /**&#10;     * Business logic for valid status transitions.&#10;     * State machine implementation.&#10;     */&#10;    private boolean canTransitionTo(TravelRequestStatus targetStatus) {&#10;        if (this.status == targetStatus) {&#10;            return false;&#10;        }&#10;&#10;        return switch (this.status) {&#10;            case DRAFT -&gt; targetStatus == TravelRequestStatus.SUBMITTED;&#10;            case SUBMITTED -&gt; targetStatus == TravelRequestStatus.APPROVED ||&#10;                             targetStatus == TravelRequestStatus.REJECTED;&#10;            case APPROVED -&gt; targetStatus == TravelRequestStatus.PAID;&#10;            case PAID -&gt; targetStatus == TravelRequestStatus.ARCHIVED;&#10;            case REJECTED, ARCHIVED -&gt; false; // Terminal states&#10;        };&#10;    }&#10;&#10;    /**&#10;     * @deprecated Use updateStatus() instead for business logic and event publishing&#10;     */&#10;    @Deprecated(forRemoval = true)&#10;    public void setStatus(TravelRequestStatus status) {&#10;        this.status = status;&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Archiviert den Reiseantrag&#10;     *&#10;     * Invarianten:&#10;     * - Status muss PAID sein&#10;     * - Darf nicht bereits archiviert sein&#10;     *&#10;     * @throws CannotArchiveTravelRequestException wenn Archivierung nicht möglich&#10;     */&#10;    public void archive() {&#10;        validateCanBeArchived();&#10;&#10;        this.status = TravelRequestStatus.ARCHIVED;&#10;        this.retentionPeriod = RetentionPeriod.standard();&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Archiviert mit benutzerdefinierter Frist&#10;     */&#10;    public void archiveWithCustomRetention(int retentionYears) {&#10;        validateCanBeArchived();&#10;&#10;        this.status = TravelRequestStatus.ARCHIVED;&#10;        this.retentionPeriod = RetentionPeriod.custom(java.time.LocalDate.now(), retentionYears);&#10;    }&#10;&#10;    /**&#10;     * Prüft, ob Archivierung erlaubt ist&#10;     */&#10;    private void validateCanBeArchived() {&#10;        if (this.status != TravelRequestStatus.PAID) {&#10;            throw new CannotArchiveTravelRequestException(&#10;                this.id,&#10;                &quot;Nur ausgezahlte Reisen können archiviert werden (aktueller Status: &quot; + this.status + &quot;)&quot;&#10;            );&#10;        }&#10;&#10;        if (this.status == TravelRequestStatus.ARCHIVED) {&#10;            throw new CannotArchiveTravelRequestException(&#10;                this.id,&#10;                &quot;Reise ist bereits archiviert&quot;&#10;            );&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Prüft, ob die Aufbewahrungsfrist abgelaufen ist&#10;     */&#10;    public boolean canBeDeleted() {&#10;        return this.status == TravelRequestStatus.ARCHIVED&#10;            &amp;&amp; this.retentionPeriod != null&#10;            &amp;&amp; this.retentionPeriod.isExpired();&#10;    }&#10;&#10;    /**&#10;     * Business-Query: Ist archiviert?&#10;     */&#10;    public boolean isArchived() {&#10;        return this.status == TravelRequestStatus.ARCHIVED;&#10;    }&#10;&#10;    public RetentionPeriod getRetentionPeriod() {&#10;        return retentionPeriod;&#10;    }&#10;&#10;    /**&#10;     * Gibt das Archivierungsdatum zurück (delegiert an RetentionPeriod)&#10;     */&#10;    public LocalDate getArchivedAt() {&#10;        return retentionPeriod != null ? retentionPeriod.getArchivedAt() : null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/infrastructure/persistence/JpaTravelRequestRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/infrastructure/persistence/JpaTravelRequestRepository.java" />
              <option name="originalContent" value="package com.travelreimburse.infrastructure.persistence;&#10;&#10;import com.travelreimburse.domain.model.TravelRequest;&#10;import com.travelreimburse.domain.repository.TravelRequestRepository;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * JPA Repository Implementierung für TravelRequest&#10; * Kombiniert Spring Data JPA mit dem Domain Repository Interface&#10; * &#10; * Spring Data JPA generiert automatisch die Implementierung für:&#10; * - save(), findById(), findAll(), delete(), etc. (von JpaRepository)&#10; * - findByEmployeeId() (durch Methodennamen-Parsing)&#10; */&#10;@Repository&#10;public interface JpaTravelRequestRepository &#10;    extends JpaRepository&lt;TravelRequest, Long&gt;, TravelRequestRepository {&#10;    &#10;    /**&#10;     * Spring Data JPA generiert automatisch die Query:&#10;     * SELECT * FROM travel_requests WHERE employee_id = ?&#10;     */&#10;    @Override&#10;    List&lt;TravelRequest&gt; findByEmployeeId(Long employeeId);&#10;&#10;    /**&#10;     * Spring Data JPA generiert automatisch die Query:&#10;     * SELECT * FROM travel_requests WHERE status = 'SUBMITTED'&#10;     * Diese Methode ist JPA-spezifisch und nicht im Domain-Interface&#10;     */&#10;    List&lt;TravelRequest&gt; findByStatus(com.travelreimburse.domain.model.TravelRequestStatus status);&#10;&#10;    /**&#10;     * Findet alle eingereichten Anträge (Implementierung für Domain-Interface)&#10;     */&#10;    @Override&#10;    default List&lt;TravelRequest&gt; findPendingApprovals() {&#10;        return findByStatus(com.travelreimburse.domain.model.TravelRequestStatus.SUBMITTED);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.travelreimburse.infrastructure.persistence;&#10;&#10;import com.travelreimburse.domain.model.TravelRequest;&#10;import com.travelreimburse.domain.repository.TravelRequestRepository;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;&#10;/**&#10; * JPA Repository Implementierung für TravelRequest&#10; * Kombiniert Spring Data JPA mit dem Domain Repository Interface&#10; * &#10; * Spring Data JPA generiert automatisch die Implementierung für:&#10; * - save(), findById(), findAll(), delete(), etc. (von JpaRepository)&#10; * - findByEmployeeId() (durch Methodennamen-Parsing)&#10; */&#10;@Repository&#10;public interface JpaTravelRequestRepository &#10;    extends JpaRepository&lt;TravelRequest, Long&gt;, TravelRequestRepository {&#10;    &#10;    /**&#10;     * Spring Data JPA generiert automatisch die Query:&#10;     * SELECT * FROM travel_requests WHERE employee_id = ?&#10;     */&#10;    @Override&#10;    List&lt;TravelRequest&gt; findByEmployeeId(Long employeeId);&#10;&#10;    /**&#10;     * Spring Data JPA generiert automatisch die Query:&#10;     * SELECT * FROM travel_requests WHERE status = 'SUBMITTED'&#10;     * Diese Methode ist JPA-spezifisch und nicht im Domain-Interface&#10;     */&#10;    List&lt;TravelRequest&gt; findByStatus(com.travelreimburse.domain.model.TravelRequestStatus status);&#10;&#10;    /**&#10;     * Findet alle eingereichten Antrge (Implementierung fr Domain-Interface)&#10;     */&#10;    @Override&#10;    default List&lt;TravelRequest&gt; findPendingApprovals() {&#10;        return findByStatus(com.travelreimburse.domain.model.TravelRequestStatus.SUBMITTED);&#10;    }&#10;&#10;    @Query(&quot;SELECT tr FROM TravelRequest tr WHERE tr.status = 'PAID'&quot;)&#10;    List&lt;TravelRequest&gt; findAllReadyForArchiving();&#10;&#10;    @Query(&quot;SELECT tr FROM TravelRequest tr &quot; +&#10;           &quot;WHERE tr.status = 'ARCHIVED' &quot; +&#10;           &quot;AND tr.retentionPeriod.retentionEndDate &lt; CURRENT_DATE&quot;)&#10;    List&lt;TravelRequest&gt; findAllWithExpiredRetention();&#10;&#10;    @Query(&quot;SELECT tr FROM TravelRequest tr &quot; +&#10;           &quot;WHERE tr.status = 'ARCHIVED' &quot; +&#10;           &quot;AND tr.retentionPeriod.archivedAt BETWEEN :startDate AND :endDate&quot;)&#10;    List&lt;TravelRequest&gt; findArchivedBetween(&#10;        @Param(&quot;startDate&quot;) LocalDate startDate,&#10;        @Param(&quot;endDate&quot;) LocalDate endDate&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>