<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/domain/model/TravelRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TravelReimburse/backend/src/main/java/com/travelreimburse/domain/model/TravelRequest.java" />
              <option name="originalContent" value="package com.travelreimburse.domain.model;&#10;&#10;import com.travelreimburse.domain.event.travelrequest.TravelRequestStatusChangedEvent;&#10;import com.travelreimburse.domain.exception.InvalidStatusTransitionException;&#10;import jakarta.persistence.*;&#10;import org.springframework.data.domain.AbstractAggregateRoot;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Aggregate Root für Reiseanträge&#10; * Verwaltet alle Informationen zu einer beantragten Dienstreise inklusive Reiserouten&#10; */&#10;@Entity&#10;@Table(name = &quot;travel_requests&quot;)&#10;public class TravelRequest extends AbstractAggregateRoot&lt;TravelRequest&gt; {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false)&#10;    private Long employeeId;&#10;    &#10;    @Column(nullable = false, length = 500)&#10;    private String destination;&#10;    &#10;    @Column(nullable = false, length = 1000)&#10;    private String purpose;&#10;    &#10;    @Embedded&#10;    private DateRange travelPeriod;&#10;    &#10;    @Embedded&#10;    @AttributeOverrides({&#10;        @AttributeOverride(name = &quot;amount&quot;, column = @Column(name = &quot;estimated_amount&quot;)),&#10;        @AttributeOverride(name = &quot;currency&quot;, column = @Column(name = &quot;estimated_currency&quot;))&#10;    })&#10;    private Money estimatedCost;&#10;    &#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private TravelRequestStatus status;&#10;    &#10;    @Column(nullable = false)&#10;    private LocalDateTime createdAt;&#10;    &#10;    @Column&#10;    private LocalDateTime submittedAt;&#10;    &#10;    @Column&#10;    private Long approverId;&#10;&#10;    @Column&#10;    private LocalDateTime approvedAt;&#10;&#10;    @Column&#10;    private LocalDateTime rejectedAt;&#10;&#10;    @Column(length = 1000)&#10;    private String rejectionReason;&#10;    &#10;    @OneToMany(mappedBy = &quot;travelRequest&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private List&lt;TravelLeg&gt; travelLegs = new ArrayList&lt;&gt;();&#10;&#10;    // JPA benötigt Default-Konstruktor&#10;    protected TravelRequest() {&#10;    }&#10;    &#10;    /**&#10;     * Erstellt einen neuen Reiseantrag im Status DRAFT&#10;     */&#10;    public TravelRequest(Long employeeId, String destination, String purpose, &#10;                         DateRange travelPeriod, Money estimatedCost) {&#10;        if (employeeId == null) {&#10;            throw new IllegalArgumentException(&quot;EmployeeId darf nicht null sein&quot;);&#10;        }&#10;        if (destination == null || destination.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reiseziel darf nicht leer sein&quot;);&#10;        }&#10;        if (purpose == null || purpose.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reisezweck darf nicht leer sein&quot;);&#10;        }&#10;        if (travelPeriod == null) {&#10;            throw new IllegalArgumentException(&quot;Reisezeitraum darf nicht null sein&quot;);&#10;        }&#10;        if (estimatedCost == null) {&#10;            throw new IllegalArgumentException(&quot;Geschätzte Kosten dürfen nicht null sein&quot;);&#10;        }&#10;        &#10;        this.employeeId = employeeId;&#10;        this.destination = destination;&#10;        this.purpose = purpose;&#10;        this.travelPeriod = travelPeriod;&#10;        this.estimatedCost = estimatedCost;&#10;        this.status = TravelRequestStatus.DRAFT;&#10;        this.createdAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag einreichen&#10;     * Zustandsübergang: DRAFT -&gt; SUBMITTED&#10;     */&#10;    public void submit() {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur Entwürfe können eingereicht werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.SUBMITTED;&#10;        this.submittedAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag genehmigen&#10;     * Zustandsübergang: SUBMITTED -&gt; APPROVED&#10;     *&#10;     * @param approverId ID der genehmigenden Führungskraft&#10;     */&#10;    public void approve(Long approverId) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können genehmigt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.APPROVED;&#10;        this.approverId = approverId;&#10;        this.approvedAt = LocalDateTime.now();&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Reiseantrag ablehnen&#10;     * Zustandsübergang: SUBMITTED -&gt; REJECTED&#10;     *&#10;     * @param approverId ID der ablehnenden Führungskraft&#10;     * @param reason Grund für die Ablehnung&#10;     */&#10;    public void reject(Long approverId, String reason) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (reason == null || reason.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Ablehnungsgrund darf nicht leer sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können abgelehnt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.REJECTED;&#10;        this.approverId = approverId;&#10;        this.rejectedAt = LocalDateTime.now();&#10;        this.rejectionReason = reason;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt hinzufügen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public TravelLeg addTravelLeg(String departureLocation, String arrivalLocation, &#10;                                  TransportationType transportationType, Money cost) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus hinzugefügt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg travelLeg = new TravelLeg(this, departureLocation, arrivalLocation, &#10;                                            transportationType, cost);&#10;        this.travelLegs.add(travelLeg);&#10;        return travelLeg;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLeg(TravelLeg travelLeg) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        if (travelLeg == null) {&#10;            throw new IllegalArgumentException(&quot;TravelLeg darf nicht null sein&quot;);&#10;        }&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        travelLeg.setTravelRequest(null);&#10;        this.travelLegs.remove(travelLeg);&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt anhand der ID entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLegById(Long legId) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg legToRemove = this.travelLegs.stream()&#10;            .filter(leg -&gt; leg.getId() != null &amp;&amp; leg.getId().equals(legId))&#10;            .findFirst()&#10;            .orElseThrow(() -&gt; new IllegalArgumentException(&quot;TravelLeg mit ID &quot; + legId + &quot; nicht gefunden&quot;));&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        legToRemove.setTravelRequest(null);&#10;        this.travelLegs.remove(legToRemove);&#10;    }&#10;    &#10;    /**&#10;     * Gibt eine unveränderliche Liste aller Reiseabschnitte zurück&#10;     */&#10;    public List&lt;TravelLeg&gt; getTravelLegs() {&#10;        return Collections.unmodifiableList(travelLegs);&#10;    }&#10;    &#10;    /**&#10;     * Berechnet die Gesamtkosten aller Reiseabschnitte&#10;     * Alle Währungen müssen identisch sein&#10;     */&#10;    public Money calculateTotalLegCost() {&#10;        if (travelLegs.isEmpty()) {&#10;            return estimatedCost;&#10;        }&#10;        &#10;        Currency baseCurrency = travelLegs.get(0).getCost().getCurrency();&#10;        Money total = new Money(java.math.BigDecimal.ZERO, baseCurrency);&#10;        &#10;        for (TravelLeg leg : travelLegs) {&#10;            if (!leg.getCost().getCurrency().equals(baseCurrency)) {&#10;                throw new IllegalStateException(&#10;                    &quot;Alle Reiseabschnitte müssen die gleiche Währung haben&quot;&#10;                );&#10;            }&#10;            total = new Money(&#10;                total.getAmount().add(leg.getCost().getAmount()), &#10;                baseCurrency&#10;            );&#10;        }&#10;        &#10;        return total;&#10;    }&#10;&#10;    // Getters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;    &#10;    public Long getEmployeeId() {&#10;        return employeeId;&#10;    }&#10;    &#10;    public String getDestination() {&#10;        return destination;&#10;    }&#10;    &#10;    public String getPurpose() {&#10;        return purpose;&#10;    }&#10;    &#10;    public DateRange getTravelPeriod() {&#10;        return travelPeriod;&#10;    }&#10;    &#10;    public Money getEstimatedCost() {&#10;        return estimatedCost;&#10;    }&#10;    &#10;    public TravelRequestStatus getStatus() {&#10;        return status;&#10;    }&#10;    &#10;    public LocalDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;    &#10;    public LocalDateTime getSubmittedAt() {&#10;        return submittedAt;&#10;    }&#10;&#10;    public Long getApproverId() {&#10;        return approverId;&#10;    }&#10;&#10;    public LocalDateTime getApprovedAt() {&#10;        return approvedAt;&#10;    }&#10;&#10;    public LocalDateTime getRejectedAt() {&#10;        return rejectedAt;&#10;    }&#10;&#10;    public String getRejectionReason() {&#10;        return rejectionReason;&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Status ändern mit Validierung und Event Publishing&#10;     * DDD: Rich Domain Model - Business logic belongs in the entity&#10;     */&#10;    public void updateStatus(TravelRequestStatus newStatus) {&#10;        if (newStatus == null) {&#10;            throw new IllegalArgumentException(&quot;Status cannot be null&quot;);&#10;        }&#10;        if (!canTransitionTo(newStatus)) {&#10;            throw new InvalidStatusTransitionException(&#10;                String.format(&quot;Cannot transition from %s to %s for TravelRequest %d&quot;,&#10;                    this.status, newStatus, this.id)&#10;            );&#10;        }&#10;&#10;        TravelRequestStatus oldStatus = this.status;&#10;        this.status = newStatus;&#10;&#10;        // Register domain event (will be published on save)&#10;        registerEvent(new TravelRequestStatusChangedEvent(&#10;            this.id,&#10;            oldStatus,&#10;            newStatus&#10;        ));&#10;    }&#10;&#10;    /**&#10;     * Business logic for valid status transitions.&#10;     * State machine implementation.&#10;     */&#10;    private boolean canTransitionTo(TravelRequestStatus targetStatus) {&#10;        if (this.status == targetStatus) {&#10;            return false;&#10;        }&#10;&#10;        return switch (this.status) {&#10;            case DRAFT -&gt; targetStatus == TravelRequestStatus.SUBMITTED;&#10;            case SUBMITTED -&gt; targetStatus == TravelRequestStatus.APPROVED ||&#10;                             targetStatus == TravelRequestStatus.REJECTED;&#10;            case APPROVED -&gt; targetStatus == TravelRequestStatus.COMPLETED ||&#10;                            targetStatus == TravelRequestStatus.CANCELLED;&#10;            case REJECTED, CANCELLED, COMPLETED -&gt; false;&#10;        };&#10;    }&#10;&#10;    /**&#10;     * @deprecated Use updateStatus() instead for business logic and event publishing&#10;     */&#10;    @Deprecated(forRemoval = true)&#10;    public void setStatus(TravelRequestStatus status) {&#10;        this.status = status;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.travelreimburse.domain.model;&#10;&#10;import com.travelreimburse.domain.event.travelrequest.TravelRequestStatusChangedEvent;&#10;import com.travelreimburse.domain.exception.InvalidStatusTransitionException;&#10;import jakarta.persistence.*;&#10;import org.springframework.data.domain.AbstractAggregateRoot;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;/**&#10; * Aggregate Root für Reiseanträge&#10; * Verwaltet alle Informationen zu einer beantragten Dienstreise inklusive Reiserouten&#10; */&#10;@Entity&#10;@Table(name = &quot;travel_requests&quot;)&#10;public class TravelRequest extends AbstractAggregateRoot&lt;TravelRequest&gt; {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false)&#10;    private Long employeeId;&#10;    &#10;    @Column(nullable = false, length = 500)&#10;    private String destination;&#10;    &#10;    @Column(nullable = false, length = 1000)&#10;    private String purpose;&#10;    &#10;    @Embedded&#10;    private DateRange travelPeriod;&#10;    &#10;    @Embedded&#10;    @AttributeOverrides({&#10;        @AttributeOverride(name = &quot;amount&quot;, column = @Column(name = &quot;estimated_amount&quot;)),&#10;        @AttributeOverride(name = &quot;currency&quot;, column = @Column(name = &quot;estimated_currency&quot;))&#10;    })&#10;    private Money estimatedCost;&#10;    &#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private TravelRequestStatus status;&#10;    &#10;    @Column(nullable = false)&#10;    private LocalDateTime createdAt;&#10;    &#10;    @Column&#10;    private LocalDateTime submittedAt;&#10;    &#10;    @Column&#10;    private Long approverId;&#10;&#10;    @Column&#10;    private LocalDateTime approvedAt;&#10;&#10;    @Column&#10;    private LocalDateTime rejectedAt;&#10;&#10;    @Column(length = 1000)&#10;    private String rejectionReason;&#10;    &#10;    @OneToMany(mappedBy = &quot;travelRequest&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private List&lt;TravelLeg&gt; travelLegs = new ArrayList&lt;&gt;();&#10;&#10;    // JPA benötigt Default-Konstruktor&#10;    protected TravelRequest() {&#10;    }&#10;    &#10;    /**&#10;     * Erstellt einen neuen Reiseantrag im Status DRAFT&#10;     */&#10;    public TravelRequest(Long employeeId, String destination, String purpose, &#10;                         DateRange travelPeriod, Money estimatedCost) {&#10;        if (employeeId == null) {&#10;            throw new IllegalArgumentException(&quot;EmployeeId darf nicht null sein&quot;);&#10;        }&#10;        if (destination == null || destination.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reiseziel darf nicht leer sein&quot;);&#10;        }&#10;        if (purpose == null || purpose.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Reisezweck darf nicht leer sein&quot;);&#10;        }&#10;        if (travelPeriod == null) {&#10;            throw new IllegalArgumentException(&quot;Reisezeitraum darf nicht null sein&quot;);&#10;        }&#10;        if (estimatedCost == null) {&#10;            throw new IllegalArgumentException(&quot;Geschätzte Kosten dürfen nicht null sein&quot;);&#10;        }&#10;        &#10;        this.employeeId = employeeId;&#10;        this.destination = destination;&#10;        this.purpose = purpose;&#10;        this.travelPeriod = travelPeriod;&#10;        this.estimatedCost = estimatedCost;&#10;        this.status = TravelRequestStatus.DRAFT;&#10;        this.createdAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag einreichen&#10;     * Zustandsübergang: DRAFT -&gt; SUBMITTED&#10;     */&#10;    public void submit() {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur Entwürfe können eingereicht werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.SUBMITTED;&#10;        this.submittedAt = LocalDateTime.now();&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseantrag genehmigen&#10;     * Zustandsübergang: SUBMITTED -&gt; APPROVED&#10;     *&#10;     * @param approverId ID der genehmigenden Führungskraft&#10;     */&#10;    public void approve(Long approverId) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können genehmigt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.APPROVED;&#10;        this.approverId = approverId;&#10;        this.approvedAt = LocalDateTime.now();&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Reiseantrag ablehnen&#10;     * Zustandsübergang: SUBMITTED -&gt; REJECTED&#10;     *&#10;     * @param approverId ID der ablehnenden Führungskraft&#10;     * @param reason Grund für die Ablehnung&#10;     */&#10;    public void reject(Long approverId, String reason) {&#10;        if (approverId == null) {&#10;            throw new IllegalArgumentException(&quot;ApproverId darf nicht null sein&quot;);&#10;        }&#10;        if (reason == null || reason.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Ablehnungsgrund darf nicht leer sein&quot;);&#10;        }&#10;        if (status != TravelRequestStatus.SUBMITTED) {&#10;            throw new IllegalStateException(&#10;                &quot;Nur eingereichte Anträge können abgelehnt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        this.status = TravelRequestStatus.REJECTED;&#10;        this.approverId = approverId;&#10;        this.rejectedAt = LocalDateTime.now();&#10;        this.rejectionReason = reason;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt hinzufügen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public TravelLeg addTravelLeg(String departureLocation, String arrivalLocation, &#10;                                  TransportationType transportationType, Money cost) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus hinzugefügt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg travelLeg = new TravelLeg(this, departureLocation, arrivalLocation, &#10;                                            transportationType, cost);&#10;        this.travelLegs.add(travelLeg);&#10;        return travelLeg;&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLeg(TravelLeg travelLeg) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        if (travelLeg == null) {&#10;            throw new IllegalArgumentException(&quot;TravelLeg darf nicht null sein&quot;);&#10;        }&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        travelLeg.setTravelRequest(null);&#10;        this.travelLegs.remove(travelLeg);&#10;    }&#10;    &#10;    /**&#10;     * Business-Methode: Reiseabschnitt anhand der ID entfernen&#10;     * Darf nur im Status DRAFT erfolgen&#10;     */&#10;    public void removeTravelLegById(Long legId) {&#10;        if (status != TravelRequestStatus.DRAFT) {&#10;            throw new IllegalStateException(&#10;                &quot;Reiseabschnitte können nur im Entwurfsstatus entfernt werden. Aktueller Status: &quot; + status&#10;            );&#10;        }&#10;        &#10;        TravelLeg legToRemove = this.travelLegs.stream()&#10;            .filter(leg -&gt; leg.getId() != null &amp;&amp; leg.getId().equals(legId))&#10;            .findFirst()&#10;            .orElseThrow(() -&gt; new IllegalArgumentException(&quot;TravelLeg mit ID &quot; + legId + &quot; nicht gefunden&quot;));&#10;        &#10;        // Bidirektionale Beziehung auflösen&#10;        legToRemove.setTravelRequest(null);&#10;        this.travelLegs.remove(legToRemove);&#10;    }&#10;    &#10;    /**&#10;     * Gibt eine unveränderliche Liste aller Reiseabschnitte zurück&#10;     */&#10;    public List&lt;TravelLeg&gt; getTravelLegs() {&#10;        return Collections.unmodifiableList(travelLegs);&#10;    }&#10;    &#10;    /**&#10;     * Berechnet die Gesamtkosten aller Reiseabschnitte&#10;     * Alle Währungen müssen identisch sein&#10;     */&#10;    public Money calculateTotalLegCost() {&#10;        if (travelLegs.isEmpty()) {&#10;            return estimatedCost;&#10;        }&#10;        &#10;        Currency baseCurrency = travelLegs.get(0).getCost().getCurrency();&#10;        Money total = new Money(java.math.BigDecimal.ZERO, baseCurrency);&#10;        &#10;        for (TravelLeg leg : travelLegs) {&#10;            if (!leg.getCost().getCurrency().equals(baseCurrency)) {&#10;                throw new IllegalStateException(&#10;                    &quot;Alle Reiseabschnitte müssen die gleiche Währung haben&quot;&#10;                );&#10;            }&#10;            total = new Money(&#10;                total.getAmount().add(leg.getCost().getAmount()), &#10;                baseCurrency&#10;            );&#10;        }&#10;        &#10;        return total;&#10;    }&#10;&#10;    // Getters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;    &#10;    public Long getEmployeeId() {&#10;        return employeeId;&#10;    }&#10;    &#10;    public String getDestination() {&#10;        return destination;&#10;    }&#10;    &#10;    public String getPurpose() {&#10;        return purpose;&#10;    }&#10;    &#10;    public DateRange getTravelPeriod() {&#10;        return travelPeriod;&#10;    }&#10;    &#10;    public Money getEstimatedCost() {&#10;        return estimatedCost;&#10;    }&#10;    &#10;    public TravelRequestStatus getStatus() {&#10;        return status;&#10;    }&#10;    &#10;    public LocalDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;    &#10;    public LocalDateTime getSubmittedAt() {&#10;        return submittedAt;&#10;    }&#10;&#10;    public Long getApproverId() {&#10;        return approverId;&#10;    }&#10;&#10;    public LocalDateTime getApprovedAt() {&#10;        return approvedAt;&#10;    }&#10;&#10;    public LocalDateTime getRejectedAt() {&#10;        return rejectedAt;&#10;    }&#10;&#10;    public String getRejectionReason() {&#10;        return rejectionReason;&#10;    }&#10;&#10;    /**&#10;     * Business-Methode: Status ändern mit Validierung und Event Publishing&#10;     * DDD: Rich Domain Model - Business logic belongs in the entity&#10;     */&#10;    public void updateStatus(TravelRequestStatus newStatus) {&#10;        if (newStatus == null) {&#10;            throw new IllegalArgumentException(&quot;Status cannot be null&quot;);&#10;        }&#10;        if (!canTransitionTo(newStatus)) {&#10;            throw new InvalidStatusTransitionException(&#10;                String.format(&quot;Cannot transition from %s to %s for TravelRequest %d&quot;,&#10;                    this.status, newStatus, this.id)&#10;            );&#10;        }&#10;&#10;        TravelRequestStatus oldStatus = this.status;&#10;        this.status = newStatus;&#10;&#10;        // Register domain event (will be published on save)&#10;        registerEvent(new TravelRequestStatusChangedEvent(&#10;            this.id,&#10;            oldStatus,&#10;            newStatus&#10;        ));&#10;    }&#10;&#10;    /**&#10;     * Business logic for valid status transitions.&#10;     * State machine implementation.&#10;     */&#10;    private boolean canTransitionTo(TravelRequestStatus targetStatus) {&#10;        if (this.status == targetStatus) {&#10;            return false;&#10;        }&#10;&#10;        return switch (this.status) {&#10;            case DRAFT -&gt; targetStatus == TravelRequestStatus.SUBMITTED;&#10;            case SUBMITTED -&gt; targetStatus == TravelRequestStatus.APPROVED ||&#10;                             targetStatus == TravelRequestStatus.REJECTED;&#10;            case APPROVED, REJECTED -&gt; false; // Terminal states&#10;        };&#10;    }&#10;&#10;    /**&#10;     * @deprecated Use updateStatus() instead for business logic and event publishing&#10;     */&#10;    @Deprecated(forRemoval = true)&#10;    public void setStatus(TravelRequestStatus status) {&#10;        this.status = status;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>